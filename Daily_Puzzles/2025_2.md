## 2025/2/6

### Puzzles1

`https://leetcode.cn/problems/permutations/description/`

#### Tags

- 数组
- 回溯

#### Leetcode环境

```cpp
class Solution {
private:
    vector<vector<int>> res;
    vector<bool> used;
    vector<int> path;

    void dfs(int i, vector<int>& nums)
    {
        // path数组的元素含有n个时，则这个是一个可行的解
        // 对应了递归深度为n时退出
        if (i == nums.size())
        {
            res.push_back(path);
            return;
        }

        // 遍历可行的元素
        for (int j = 0; j < nums.size(); j ++)
        {
            if (!used[j])
            {
                used[j] = true;
                path.push_back(nums[j]);
                dfs(i+1, nums);
                path.pop_back();  // 记得要pop_back，因为这里不是通过索引来赋值的
                                  // 或者初始化n个元素之后利用赋值的方式直接覆盖
                used[j] = false;  // 恢复现场
            }
        }
    }

public:
    vector<vector<int>> permute(vector<int>& nums) {

        // 初始所有的元素都还没用
        for (int i = 0; i < nums.size(); i ++)
        {
            used.push_back(false);
        }

        // 第一个参数代表递归深度
        // 第二个参数是需要全排列的内容
        dfs(0, nums);

        return res;
    }
};
```

### Puzzles2
`https://leetcode.cn/problems/permutations-ii/description/`

#### Tags

- 数组
- 回溯
- 排序

#### Leetcode环境

```cpp
class Solution {
private:
    vector<vector<int>> res;
    vector<int> path;
    vector<bool> used;

    void dfs(int depth, vector<int>& nums)
    {
        // 这里其实也可以通过path数组的长度来进行判断
        if (depth == nums.size())
        {
            res.push_back(path);
            return;
        }

        for (int i = 0; i < nums.size(); i ++)
        {
            // 关键在于进行了排序
            if (i > 0 && nums[i - 1] == nums[i] && used[i - 1] == false)
            {
                // 用来跳过可能的重复排列
                continue;
            }

            if (!used[i])
            {
                used[i] = true;
                path.push_back(nums[i]);
                dfs(depth+1, nums);

                path.pop_back();  // 动态数组需要pop_back()
                used[i] = false;  // 恢复现场，上面那个操作也是恢复现场的一部分
            }
        }
    }


public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        sort(nums.begin(), nums.end());  // 默认从小到大排序

        for (int i = 0; i < nums.size(); i ++)
        {
            used.push_back(false);
        }

        // 第一个是递归的深度，第二个是需要排列的东西
        dfs(0, nums);

        return res;
    }
};
```