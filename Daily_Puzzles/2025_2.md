## 2025/2/6

### Puzzles1

`https://leetcode.cn/problems/permutations/description/`

#### Tags

- 数组
- 回溯

#### Leetcode环境

```cpp
class Solution {
private:
    vector<vector<int>> res;
    vector<bool> used;
    vector<int> path;

    void dfs(int i, vector<int>& nums)
    {
        // path数组的元素含有n个时，则这个是一个可行的解
        // 对应了递归深度为n时退出
        if (i == nums.size())
        {
            res.push_back(path);
            return;
        }

        // 遍历可行的元素
        for (int j = 0; j < nums.size(); j ++)
        {
            if (!used[j])
            {
                used[j] = true;
                path.push_back(nums[j]);
                dfs(i+1, nums);
                path.pop_back();  // 记得要pop_back，因为这里不是通过索引来赋值的
                                  // 或者初始化n个元素之后利用赋值的方式直接覆盖
                used[j] = false;  // 恢复现场
            }
        }
    }

public:
    vector<vector<int>> permute(vector<int>& nums) {

        // 初始所有的元素都还没用
        for (int i = 0; i < nums.size(); i ++)
        {
            used.push_back(false);
        }

        // 第一个参数代表递归深度
        // 第二个参数是需要全排列的内容
        dfs(0, nums);

        return res;
    }
};
```

### Puzzles2
`https://leetcode.cn/problems/permutations-ii/description/`

#### Tags

- 数组
- 回溯
- 排序

#### Leetcode环境

```cpp
class Solution {
private:
    vector<vector<int>> res;
    vector<int> path;
    vector<bool> used;

    void dfs(int depth, vector<int>& nums)
    {
        // 这里其实也可以通过path数组的长度来进行判断
        if (depth == nums.size())
        {
            res.push_back(path);
            return;
        }

        for (int i = 0; i < nums.size(); i ++)
        {
            // 关键在于进行了排序
            if (i > 0 && nums[i - 1] == nums[i] && used[i - 1] == false)
            {
                // 用来跳过可能的重复排列
                continue;
            }

            if (!used[i])
            {
                used[i] = true;
                path.push_back(nums[i]);
                dfs(depth+1, nums);

                path.pop_back();  // 动态数组需要pop_back()
                used[i] = false;  // 恢复现场，上面那个操作也是恢复现场的一部分
            }
        }
    }


public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        sort(nums.begin(), nums.end());  // 默认从小到大排序

        for (int i = 0; i < nums.size(); i ++)
        {
            used.push_back(false);
        }

        // 第一个是递归的深度，第二个是需要排列的东西
        dfs(0, nums);

        return res;
    }
};
```

### Puzzles3

`https://leetcode.cn/problems/binary-search/description/`

#### Tags

- 数组
- 二分查找

#### Leetcode环境
```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        // 闭区间版本
        int left = 0;
        int right  = nums.size() - 1;

        while (left <= right)
        {
            int mid = (left + right) >> 1;

            if (nums[mid] > target)
            {
                right = mid - 1;
            }
            else if (nums[mid] == target)
            {
                return mid;
            }
            else
            {
                left = mid + 1;
            }
        }

        return -1;
    }
};
```

### Puzzles4

#### Tags

- 数组
- 二分查找

#### Leetcode环境
```cpp
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;

        while (left <= right)
        {
            int mid = (left + right) / 2;
            // int mid = (left + right) >> 1;
            // int mid = left + ((right - left) >> 1);
            if (nums[mid] > target)
            {
                right = mid - 1;
            }
            else if (nums[mid] < target)
            {
                left = mid + 1;
            }
            else
            {
                return mid;
            }
        }

        return left;
    }
};
```

### Puzzles5

#### Tags

- 数组
- 二分查找

#### Leetcode环境

```cpp
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;

        vector<int> res(2, 0);

        if (nums.size() == 0)
        {
            res[0] = -1;
            res[1] = -1;
            return res;
        }

        while (left < right)
        {
            int mid = (left + right) >> 1;
            if (nums[mid] >= target)
            {
                right = mid;
            }
            else
            {
                left = mid + 1;
            }
        }

        if (nums[left] == target)
        {
            res[0] = left;

            left = 0;
            right = nums.size() - 1;

            while (left < right)
            {
                int mid = (left + right + 1) >> 1;
                if (nums[mid] <= target)
                {
                    left = mid;
                }
                else
                {
                    right = mid - 1;
                }
            }

            res[1] = left;
        }
        else
        {
            res[0] = -1;
            res[1] = -1;
            return res;
        }

        return res;
    }
};
```

### Puzzles6

#### Tags
- 数组
- 二分查找

#### Leetcode环境

```cpp
class Solution {
public:
    int mySqrt(int x) {
        int left = 0;
        int right = min(x, 46340) + 1;

        while (right - left > 1)
        {
            int mid = (left + right) >> 1;
            if (mid * mid <= x)
            {
                left = mid;
            }
            else
            {
                right = mid;
            }
        }

        return left;
    }
};
```

### Puzzles7



#### Tags

- 数组
- 二分查找

#### Leetcode环境

```cpp
class Solution {
public:
    bool isPerfectSquare(int num) {
        int left = 0;
        int right = min(num, 46340) + 1;;

        while (right - left > 1)
        {
            // cout << left << " " << right << endl;
            int mid = (left + right) / 2;

            if (mid * mid <= num)
            {
                left = mid;
            }
            else
            {
                right = mid;
            }
        }

        return (left * left == num);
    }
};
```

## 2025/2/7

### Puzzles1

`https://leetcode.cn/problems/spiral-matrix-ii/description/`

#### Tags

- 数组
- 矩阵
- 模拟

#### Leetcode环境
```python

class Solution {
private:
    // 方向数组
    int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

public:
    vector<vector<int>> generateMatrix(int n) {
        // 结果数组，vector二维初始化
        vector res(n, vector<int>(n));
        // i代表行，j代表列，di代表方向
        int i = 0, j = 0, di = 0;

        // 不断枚举要填的元素
        for (int val = 1; val <= n * n; val ++)
        {
            res[i][j] = val;
            // 下一个位置（看是否可行 1. 不越界 2. 还没有遍历过）
            int x = i + dir[di][0];
            int y = j + dir[di][1];

            // 违反上面两个条件
            if (x < 0 || x >= n || y < 0 || y >= n || res[x][y])
            {
                // 旋转90度，加一即可，同时超过3的时候回到0
                di = (di + 1) % 4;
            }

            // 最终的下一个位置
            i += dir[di][0];
            j += dir[di][1];
        }

        return res;
    }
};

```

### Puzzles2

`https://leetcode.cn/problems/spiral-matrix/`

#### Tags

- 数组
- 矩阵
- 模拟


#### Leetcode环境

```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int n = matrix.size();
        int m = matrix[0].size();
        vector used(n, vector<bool>(m, false));
        vector<int> res(n * m);


        int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

        int i = 0, j = 0, di = 0;

        for (int k = 0; k < n * m; k ++)
        {
            res[k] = matrix[i][j];
            used[i][j] = true;

            int x = i + dir[di][0];
            int y = j + dir[di][1];

            if (x < 0 || x >= n || y < 0 || y >= m || used[x][y])
            {
                di = (di + 1) % 4;
            }

            i += dir[di][0];
            j += dir[di][1];
        }

        return res;
    }
};
```

### Puzzles3

`https://leetcode.cn/problems/remove-element/description/`

#### Tags

- 数组
- 双指针

#### Leetcode环境

```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int i = 0, j = 0;

        for (; i < nums.size(); i ++)  // 遍历元素
        {
            if (nums[i] != val)
            {
                cout <<  nums[i] << endl;
                nums[j ++] = nums[i];
                continue;
            }

        }

        return j;
    }
};
```

### Puzzles4

`https://leetcode.cn/problems/move-zeroes/description/`

#### Tags

- 数组
- 双指针

#### Leetcode环境

```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int i = 0, j = 0;

        // 把非零元素前移
        for (; i < nums.size(); i ++)
        {
            if (nums[i] != 0)
            {
                nums[j ++] = nums[i];
            }
        }

        // 把后面的位置都赋值为0
        for (; j < nums.size(); j ++)
        {
            nums[j] = 0;
        }
    }
};
```