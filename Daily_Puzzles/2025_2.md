## 2025/2/6

### Puzzles1

`https://leetcode.cn/problems/permutations/description/`

#### Tags

- 数组
- 回溯

#### Leetcode环境

```cpp
class Solution {
private:
    vector<vector<int>> res;
    vector<bool> used;
    vector<int> path;

    void dfs(int i, vector<int>& nums)
    {
        // path数组的元素含有n个时，则这个是一个可行的解
        // 对应了递归深度为n时退出
        if (i == nums.size())
        {
            res.push_back(path);
            return;
        }

        // 遍历可行的元素
        for (int j = 0; j < nums.size(); j ++)
        {
            if (!used[j])
            {
                used[j] = true;
                path.push_back(nums[j]);
                dfs(i+1, nums);
                path.pop_back();  // 记得要pop_back，因为这里不是通过索引来赋值的
                                  // 或者初始化n个元素之后利用赋值的方式直接覆盖
                used[j] = false;  // 恢复现场
            }
        }
    }

public:
    vector<vector<int>> permute(vector<int>& nums) {

        // 初始所有的元素都还没用
        for (int i = 0; i < nums.size(); i ++)
        {
            used.push_back(false);
        }

        // 第一个参数代表递归深度
        // 第二个参数是需要全排列的内容
        dfs(0, nums);

        return res;
    }
};
```

### Puzzles2
`https://leetcode.cn/problems/permutations-ii/description/`

#### Tags

- 数组
- 回溯
- 排序

#### Leetcode环境

```cpp
class Solution {
private:
    vector<vector<int>> res;
    vector<int> path;
    vector<bool> used;

    void dfs(int depth, vector<int>& nums)
    {
        // 这里其实也可以通过path数组的长度来进行判断
        if (depth == nums.size())
        {
            res.push_back(path);
            return;
        }

        for (int i = 0; i < nums.size(); i ++)
        {
            // 关键在于进行了排序
            if (i > 0 && nums[i - 1] == nums[i] && used[i - 1] == false)
            {
                // 用来跳过可能的重复排列
                continue;
            }

            if (!used[i])
            {
                used[i] = true;
                path.push_back(nums[i]);
                dfs(depth+1, nums);

                path.pop_back();  // 动态数组需要pop_back()
                used[i] = false;  // 恢复现场，上面那个操作也是恢复现场的一部分
            }
        }
    }


public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        sort(nums.begin(), nums.end());  // 默认从小到大排序

        for (int i = 0; i < nums.size(); i ++)
        {
            used.push_back(false);
        }

        // 第一个是递归的深度，第二个是需要排列的东西
        dfs(0, nums);

        return res;
    }
};
```

### Puzzles3

`https://leetcode.cn/problems/binary-search/description/`

#### Tags

- 数组
- 二分查找

#### Leetcode环境
```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        // 闭区间版本
        int left = 0;
        int right  = nums.size() - 1;

        while (left <= right)
        {
            int mid = (left + right) >> 1;

            if (nums[mid] > target)
            {
                right = mid - 1;
            }
            else if (nums[mid] == target)
            {
                return mid;
            }
            else
            {
                left = mid + 1;
            }
        }

        return -1;
    }
};
```

### Puzzles4

#### Tags

- 数组
- 二分查找

#### Leetcode环境
```cpp
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;

        while (left <= right)
        {
            int mid = (left + right) / 2;
            // int mid = (left + right) >> 1;
            // int mid = left + ((right - left) >> 1);
            if (nums[mid] > target)
            {
                right = mid - 1;
            }
            else if (nums[mid] < target)
            {
                left = mid + 1;
            }
            else
            {
                return mid;
            }
        }

        return left;
    }
};
```

### Puzzles5

#### Tags

- 数组
- 二分查找

#### Leetcode环境

```cpp
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;

        vector<int> res(2, 0);

        if (nums.size() == 0)
        {
            res[0] = -1;
            res[1] = -1;
            return res;
        }

        while (left < right)
        {
            int mid = (left + right) >> 1;
            if (nums[mid] >= target)
            {
                right = mid;
            }
            else
            {
                left = mid + 1;
            }
        }

        if (nums[left] == target)
        {
            res[0] = left;

            left = 0;
            right = nums.size() - 1;

            while (left < right)
            {
                int mid = (left + right + 1) >> 1;
                if (nums[mid] <= target)
                {
                    left = mid;
                }
                else
                {
                    right = mid - 1;
                }
            }

            res[1] = left;
        }
        else
        {
            res[0] = -1;
            res[1] = -1;
            return res;
        }

        return res;
    }
};
```

### Puzzles6

#### Tags
- 数组
- 二分查找

#### Leetcode环境

```cpp
class Solution {
public:
    int mySqrt(int x) {
        int left = 0;
        int right = min(x, 46340) + 1;

        while (right - left > 1)
        {
            int mid = (left + right) >> 1;
            if (mid * mid <= x)
            {
                left = mid;
            }
            else
            {
                right = mid;
            }
        }

        return left;
    }
};
```

### Puzzles7

#### Tags

- 数组
- 二分查找

#### Leetcode环境

```cpp
class Solution {
public:
    bool isPerfectSquare(int num) {
        int left = 0;
        int right = min(num, 46340) + 1;;

        while (right - left > 1)
        {
            // cout << left << " " << right << endl;
            int mid = (left + right) / 2;

            if (mid * mid <= num)
            {
                left = mid;
            }
            else
            {
                right = mid;
            }
        }

        return (left * left == num);
    }
};
```